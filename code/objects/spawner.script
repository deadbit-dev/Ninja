local config = require "code.config"
local State = require "code.state"
local EventBus = require "code.modules.utils.eventbus"

go.property("units", 0)
go.property("interval", 0)

function init(self)
  self.id = go.get_id()
  self.spawning = false

  EventBus:subscribe(config.ON_START_SPAWN, self.id)
  EventBus:subscribe(config.ON_STOP_SPAWN, self.id)
end

function on_message(self, message_id)
  if message_id == config.ON_START_SPAWN and not self.spawning then
    start_spawn(self)
  end

  if message_id == config.ON_STOP_SPAWN then
    stop_spawn(self)
  end
end

function update(self, dt)
  if not self.spawning then
    return
  end

  local delay = self.interval / self.units
  if delay < self.duration then
    print(delay)
    spawn()
    self.duration = 0
  end

  self.duration = self.duration + dt
end

function start_spawn(self)
  self.spawning = true
  self.units = config.UNITS_SPAWN_MIN
  self.interval = config.SPAWN_INTERVAL_MIN
  self.duration = 0

  go.animate("#", "units", 
    config.UNITS_SPAWN_PLAYBACK, 
    config.UNITS_SPAWN_MAX, 
    config.UNITS_SPAWN_EASING, 
    config.UNITS_SPAWN_DURATION
  )
  go.animate("#", "interval", 
    config.SPAWN_INTERVAL_PLAYBACK, 
    config.SPAWN_INTERVAL_MAX, 
    config.SPAWN_INTERVAL_EASING, 
    config.SPAWN_INTERVAL_DURATION
  )
end

function stop_spawn(self)
  self.spawning = false
end

function spawn()
  local data = config.GENERATOR:get_next_data()
  local unit = config.SPAWNER:spawn(data.unit)

  State.context.units[unit] = data.modification
  EventBus:emit(config.ON_SPAWN_UNIT, {unit = unit})
end